/*
  Copyright (C) 2019 European Space Agency - <maxime.perrotin@esa.int>

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Library General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Library General Public License for more details.

  You should have received a copy of the GNU Library General Public License
  along with this program. If not, see <https://www.gnu.org/licenses/lgpl-2.1.html>.
*/

#include "aadliface.h"

#include "aadlcommonprops.h"
#include "aadlconnection.h"
#include "aadlfunction.h"
#include "aadlmodel.h"
#include "aadlnamevalidator.h"

#include <QDebug>
#include <QMetaEnum>

namespace ivm {

AADLIface::CreationInfo::CreationInfo(AADLModel *model, AADLFunctionType *function, const QPointF &position,
        AADLIface::IfaceType type, const shared::Id &id, const QVector<IfaceParameter> &parameters, OperationKind kind,
        const QString &name, const CreationInfo::Policy policy, AADLIface *source)
    : model(model)
    , function(function)
    , position(position)
    , type(type)
    , id(id)
    , parameters(parameters)
    , kind(kind)
    , name(name)
    , policy(policy)
    , toBeCloned(policy == Policy::Clone ? source : nullptr)
{
}

QVariantList AADLIface::CreationInfo::toVarList() const
{
    return { QVariant::fromValue(*this) };
}

AADLIface::CreationInfo AADLIface::CreationInfo::initFromIface(AADLIface *iface, const CreationInfo::Policy policy)
{
    if (!iface)
        return {};

    auto getIfacePos = [](const QVector<qint32> &coordinates) {
        return coordinates.size() < 2 ? QPointF() : QPointF(coordinates.front(), coordinates.back());
    };

    return { iface->objectsModel(), (iface->parentObject() ? iface->parentObject()->as<AADLFunctionType *>() : nullptr),
        getIfacePos(iface->coordinates()), iface->direction(), iface->id(), iface->params(), iface->kind(),
        iface->title(), policy, iface };
}

AADLIface::CreationInfo AADLIface::CreationInfo::fromIface(AADLIface *iface)
{
    AADLIface::CreationInfo info = initFromIface(iface, AADLIface::CreationInfo::Policy::Init);
    if (AADLNameValidator::isAutogeneratedName(iface))
        info.name = QString();
    return info;
}

AADLIface::CreationInfo AADLIface::CreationInfo::cloneIface(AADLIface *iface, AADLFunction *fn)
{
    AADLIface::CreationInfo info = initFromIface(iface, AADLIface::CreationInfo::Policy::Clone);
    info.function = fn;
    info.model = fn->objectsModel();
    return info;
}

void AADLIface::CreationInfo::resetKind()
{
    if (AADLIface::IfaceType::Required == type)
        kind = AADLIface::OperationKind::Any;
    else {
        if (AADLIface::OperationKind::Any == kind)
            kind = AADLIface::OperationKind::Sporadic;
    }
}

struct AADLIfacePrivate {
    explicit AADLIfacePrivate(AADLIface::IfaceType dir)
        : m_direction(dir)
    {
    }
    AADLIface::IfaceType m_direction;
    QVector<IfaceParameter> m_params = {};
    QPointer<AADLIface> m_cloneOf { nullptr };
    QVector<QPointer<AADLIface>> m_clones {};
};

AADLIface::AADLIface(AADLObject::Type ifaceType, const CreationInfo &ci)
    : AADLObject(ifaceType, ci.name, ci.function, ci.toBeCloned ? shared::createId() : ci.id)
    , d(new AADLIfacePrivate(Type::InterfaceGroup == ifaceType
                      ? ci.type
                      : Type::RequiredInterface == ifaceType ? AADLIface::IfaceType::Required
                                                             : AADLIface::IfaceType::Provided))
{
    setupInitialAttrs();

    setKind(ci.kind);
    setParams(ci.parameters);

    if (ci.toBeCloned)
        setCloneOrigin(ci.toBeCloned);
}

AADLIface::~AADLIface()
{
    if (d->m_cloneOf)
        d->m_cloneOf->forgetClone(this);
}

void AADLIface::setupInitialAttrs()
{
    setAttr(meta::Props::token(meta::Props::Token::kind), kindToString(defaultKind()));
    if (isProvided()) {
        setAttr(meta::Props::token(meta::Props::Token::period), QVariant());
        setAttr(meta::Props::token(meta::Props::Token::wcet), QVariant());
        setAttr(meta::Props::token(meta::Props::Token::queue_size), QVariant());
    } else {
        setProp(meta::Props::token(meta::Props::Token::InheritPI), true);
    }
}

AADLIface::IfaceType AADLIface::direction() const
{
    return d->m_direction;
}

bool AADLIface::isProvided() const
{
    return direction() == IfaceType::Provided;
}
bool AADLIface::isRequired() const
{
    return direction() == IfaceType::Required;
}

QMap<AADLIface::OperationKind, QString> AADLIface::availableKindNames() const
{
    QMap<AADLIface::OperationKind, QString> result;
    if (result.isEmpty()) {
        const QMetaEnum &me = QMetaEnum::fromType<ivm::AADLIface::OperationKind>();
        for (int i = 0; i < me.keyCount(); ++i) {
            const AADLIface::OperationKind k = static_cast<AADLIface::OperationKind>(me.value(i));
            if ((isProvided() && k == OperationKind::Any) || (isRequired() && k == OperationKind::Cyclic)) {
                continue;
            }
            result.insert(k, QString(me.key(i)));
        }
    }
    return result;
}

QString AADLIface::kindToString(AADLIface::OperationKind k)
{
    const QMetaEnum &me = QMetaEnum::fromType<ivm::AADLIface::OperationKind>();
    return QString::fromLatin1(me.valueToKey(static_cast<int>(k)));
}

AADLIface::OperationKind AADLIface::kindFromString(const QString &k, AADLIface::OperationKind defaultKind)
{
    const QMetaEnum &me = QMetaEnum::fromType<ivm::AADLIface::OperationKind>();
    bool ok = false;
    const auto kind = static_cast<AADLIface::OperationKind>(me.keyToValue(k.toLatin1().data(), &ok));
    return ok ? kind : defaultKind;
}

AADLIface::OperationKind AADLIface::defaultKind() const
{
    return isProvided() ? OperationKind::Sporadic : OperationKind::Any;
}

/*! This returns the title. Unless it's an RI of type inherited, in which case it returns a comma
 * separated list of PI connected to it - unless none are and then it's back to title.
 */
QString AADLIface::ifaceLabel() const
{
    return title();
}

AADLIface::OperationKind AADLIface::kindFromString(const QString &k) const
{
    return kindFromString(k, defaultKind());
}

AADLIface::OperationKind AADLIface::kind() const
{
    return this->kindFromString(attr(meta::Props::token(meta::Props::Token::kind)).toString());
}

bool AADLIface::setKind(AADLIface::OperationKind k)
{
    if (this->kind() != k) {
        setAttr(meta::Props::token(meta::Props::Token::kind), kindToString(k));
        return true;
    }

    return false;
}

QVector<IfaceParameter> AADLIface::params() const
{
    return d->m_params;
}

IfaceParameter AADLIface::param(const QString &name) const
{
    if (!name.isEmpty())
        for (const IfaceParameter &param : params())
            if (param.name() == name)
                return param;
    return {};
}

void AADLIface::setParams(const QVector<IfaceParameter> &params)
{
    if (d->m_params != params) {
        d->m_params = params;
        Q_EMIT paramsChanged();
    }
}

void AADLIface::addParam(const IfaceParameter &param)
{
    if (!d->m_params.contains(param)) {
        d->m_params.append(param);
        Q_EMIT paramsChanged();
    }
}

AADLFunctionType *AADLIface::function() const
{
    return qobject_cast<AADLFunctionType *>(parentObject());
}

/*!
   Returns the parent functions, the grand parent function, ... as a list.
   The first function is the direct parent function
 */
QList<AADLFunction *> AADLIface::functionsStack() const
{
    QList<AADLFunction *> result;
    AADLFunction *parentFunc = qobject_cast<AADLFunction *>(parentObject());
    while (parentFunc) {
        result.append(parentFunc);
        parentFunc = qobject_cast<AADLFunction *>(parentFunc->parentObject());
    }
    return result;
}

AADLIface *AADLIface::cloneOf() const
{
    return d->m_cloneOf;
}

bool AADLIface::isClone() const
{
    return nullptr != cloneOf();
}

bool AADLIface::isCloned() const
{
    return d->m_clones.size();
}

QVector<QPointer<AADLIface>> AADLIface::clones() const
{
    return d->m_clones;
}

void AADLIface::setCloneOrigin(AADLIface *source)
{
    if (d->m_cloneOf != source) {
        d->m_cloneOf = source;
        if (d->m_cloneOf) {
            d->m_cloneOf->rememberClone(this);
        }
    }
}

void AADLIface::rememberClone(AADLIface *clone)
{
    if (clone && !d->m_clones.contains(clone)) {
        clone->cloneInternals(this);
        d->m_clones.append(clone);
    }
}

void AADLIface::forgetClone(AADLIface *clone)
{
    if (clone)
        clone->restoreInternals(this);
    d->m_clones.removeAll(clone);
}

AADLIfaceProvided::AADLIfaceProvided(const CreationInfo &ci)
    : AADLIface(AADLObject::Type::ProvidedInterface, ci)
{
}

AADLIfaceRequired::AADLIfaceRequired(const CreationInfo &ci)
    : AADLIface(AADLObject::Type::RequiredInterface, ci)
{
    setProp(meta::Props::token(meta::Props::Token::Autonamed), AADLNameValidator::isAutogeneratedName(this));
}

AADLIface *AADLIface::createIface(const CreationInfo &descr)
{
    AADLIface *iface { nullptr };
    const bool isProvided = descr.type == AADLIface::IfaceType::Provided;
    if (isProvided)
        iface = new AADLIfaceProvided(descr);
    else
        iface = new AADLIfaceRequired(descr);
    iface->setKind(descr.kind);

    return iface;
}

bool AADLIface::storedKindDiffers() const
{
    const QString nameKind = meta::Props::token(meta::Props::Token::kind);
    return m_originalFields.attrs.value(nameKind) != attr(nameKind);
}

void AADLIface::cloneInternals(const AADLIface *from)
{
    if (!from)
        return;

    if (!m_originalFields.collected())
        m_originalFields.collect(isClone() ? d->m_cloneOf.data() : this);

    {
        QSignalBlocker sb(this);
        reflectAttrs(from);
        reflectProps(from);
        reflectParams(from);
    }

    if (storedKindDiffers())
        Q_EMIT attributeChanged(meta::Props::Token::kind);

    connect(from, qOverload<ivm::meta::Props::Token>(&AADLIface::attributeChanged), this,
            &AADLIface::onReflectedAttrChanged, Qt::UniqueConnection);
    connect(from, qOverload<ivm::meta::Props::Token>(&AADLIface::propertyChanged), this,
            &AADLIface::onReflectedPropChanged, Qt::UniqueConnection);
    connect(from, &AADLIface::paramsChanged, this, &AADLIface::onReflectedParamsChanged, Qt::UniqueConnection);
}

void AADLIface::restoreInternals(const AADLIface *disconnectMe)
{
    disconnect(disconnectMe, qOverload<ivm::meta::Props::Token>(&AADLIface::attributeChanged), this,
            &AADLIface::onReflectedAttrChanged);
    disconnect(disconnectMe, qOverload<ivm::meta::Props::Token>(&AADLIface::propertyChanged), this,
            &AADLIface::onReflectedPropChanged);
    disconnect(disconnectMe, &AADLIface::paramsChanged, this, &AADLIface::onReflectedParamsChanged);

    if (!m_originalFields.collected())
        return;

    // keep current coordinates:
    for (meta::Props::Token t : { meta::Props::Token::InnerCoordinates, meta::Props::Token::coordinates }) {
        const QString &name = meta::Props::token(t);
        if (m_originalFields.props.contains(name))
            m_originalFields.props[name] = prop(name);
    }

    const bool kindChanged = storedKindDiffers();

    {
        QSignalBlocker sb(this);

        setAttrs(m_originalFields.attrs);
        setProps(m_originalFields.props);
        setParams(m_originalFields.params);
    }

    if (kindChanged)
        Q_EMIT attributeChanged(meta::Props::Token::kind);

    m_originalFields = {};
}

QVariant AADLIface::originalAttr(const QString &name) const
{
    return m_originalFields.attrs.value(name, QVariant());
}

QVariant AADLIface::originalProp(const QString &name) const
{
    return m_originalFields.props.value(name, QVariant());
}

QVector<IfaceParameter> AADLIface::originalParams() const
{
    return m_originalFields.params;
}

void AADLIface::onReflectedAttrChanged(ivm::meta::Props::Token /*attr*/)
{
    if (AADLIface *iface = qobject_cast<AADLIface *>(sender()))
        reflectAttrs(iface);
}

void AADLIface::onReflectedPropChanged(ivm::meta::Props::Token /*prop*/)
{
    if (AADLIface *iface = qobject_cast<AADLIface *>(sender()))
        reflectProps(iface);
}

void AADLIface::onReflectedParamsChanged()
{
    if (AADLIface *iface = qobject_cast<AADLIface *>(sender()))
        reflectParams(iface);
}

void AADLIface::reflectAttrs(const AADLIface *from)
{
    if (!from)
        return;

    auto revertAttribute = [](const QString &name, QHash<QString, QVariant> &attrs,
                                   const QHash<QString, QVariant> &attrsOriginal) {
        const QVariant &value = attrsOriginal.value(name);
        if (value.isValid())
            attrs[name] = value;
    };

    QHash<QString, QVariant> newAttrs = from->attrs();

    const bool isFunctionTypeInherited = from->isNestedInFunctionType();
    static const QString autonamedProp = meta::Props::token(meta::Props::Token::Autonamed);
    const bool isCustomName =
            !(m_originalFields.collected() ? m_originalFields.props.value(autonamedProp, true).toBool()
                                           : prop(autonamedProp, true).toBool());
    const bool keepName = isFunctionTypeInherited || isCustomName;
    if (keepName)
        revertAttribute(meta::Props::token(meta::Props::Token::name), newAttrs, m_originalFields.attrs);

    setAttrs(newAttrs);
}

void AADLIface::reflectProps(const AADLIface *from)
{
    if (!from)
        return;

    auto revertProperty = [](meta::Props::Token t, QHash<QString, QVariant> &props,
                                  const QHash<QString, QVariant> &propsOriginal) {
        const QString &name = meta::Props::token(t);
        const QVariant &value = propsOriginal.value(name);
        if (value.isValid())
            props[name] = value;
    };

    const QHash<QString, QVariant> &currProps = props();
    QHash<QString, QVariant> newProps = from->props();
    const bool isFunctionTypeInherited = from->isNestedInFunctionType();

    for (auto t :
            { meta::Props::Token::InheritPI, meta::Props::Token::coordinates, meta::Props::Token::InnerCoordinates }) {
        const bool isInheritPIFlag = t == meta::Props::Token::InheritPI;
        const bool isInheritedPI = !isFunctionTypeInherited && isRequired() && from->isProvided();
        if (!isInheritPIFlag || isInheritedPI)
            revertProperty(t, newProps, currProps);
    }

    setProps(newProps);
}

void AADLIface::reflectParams(const AADLIface *from)
{
    if (!from)
        return;

    setParams(from->params());
}

void AADLIfaceRequired::setAttr(const QString &name, const QVariant &val)
{
    if (!name.isEmpty()) {
        const meta::Props::Token t = meta::Props::token(name);
        switch (t) {
        case meta::Props::Token::name: {
            QString usedName = val.toString();
            bool autoName;
            if (usedName.isEmpty()) {
                if (isInheritPI() && !m_prototypes.isEmpty()) {
                    usedName = m_prototypes.first()->title();
                } else {
                    usedName = AADLNameValidator::nextNameFor(this);
                }
                autoName = true;
            } else {
                if (isInheritPI()) {
                    const auto it = std::find_if(m_prototypes.cbegin(), m_prototypes.cend(),
                            [usedName](const ivm::AADLIfaceProvided *iface) { return iface->title() == usedName; });
                    if (it != m_prototypes.cend()) {
                        autoName = true;
                    } else {
                        autoName = false;
                    }
                } else {
                    autoName = false;
                }
            }

            static const QString autonamedPropName = meta::Props::token(meta::Props::Token::Autonamed);
            if (m_originalFields.collected()) {
                m_originalFields.props[autonamedPropName] = autoName;
                if (!autoName)
                    m_originalFields.attrs[name] = usedName;
            } else {
                setProp(autonamedPropName, autoName);
            }
            AADLIface::setAttr(name, usedName);
            return;
        }
        default:
            break;
        }

        AADLIface::setAttr(name, val);
    }
}

void AADLIfaceRequired::setProp(const QString &name, const QVariant &val)
{
    if (!name.isEmpty()) {
        const meta::Props::Token t = meta::Props::token(name);
        switch (t) {
        case meta::Props::Token::InheritPI: {
            const bool newVal = val.toBool();
            if (prop(meta::Props::token(meta::Props::Token::InheritPI)) != newVal) {
                // should be handled in Connection _before_ the actual value change:
                Q_EMIT inheritedLabelsChanged(inheritedLables());

                AADLObject::setProp(name, val);
                Q_EMIT propChanged_InheritPI(newVal);
            }
            break;
        }
        default:
            AADLObject::setProp(name, val);
            break;
        }
    }
}

QStringList AADLIfaceRequired::inheritedLables() const
{
    QStringList result;

    const QString &currentTitle = title();
    if (currentTitle != m_originalFields.name())
        result.append(currentTitle);
    else if (AADLNameValidator::isAutogeneratedName(this) && isInheritPI()) {
        result = collectInheritedLabels();

        // append suffix for connection to the same named PIs with same parent (Function.PI becomes Funtcion.PI#N)
        namesForRIToPIs(result);

        // if 2+ FnA.RI connected to the same FnB.PI, populate the inherited name with number suffix
        // (based on the index of the Connection among related connections)
        namesForRIsToPI(result);
    }

    if (result.isEmpty())
        result.append(currentTitle);

    return result;
}

QStringList AADLIfaceRequired::collectInheritedLabels() const
{
    QStringList result, titles;
    std::transform(m_prototypes.cbegin(), m_prototypes.cend(), std::back_inserter(titles),
            [](const AADLIfaceProvided *pi) { return pi->title(); });

    for (const AADLIfaceProvided *pi : m_prototypes) {
        QString label = pi->title();
        if (titles.count(label) > 1) {
            Q_ASSERT(pi->parentObject());
            // if PIs have same name, prepend it with parent's name
            label = pi->parentObject()->title() + "." + label;
        }
        result.prepend(label);
    }
    return result;
}

void AADLIfaceRequired::namesForRIToPIs(QStringList &result) const
{
    for (const QString &label : result) {
        int count = result.count(label);
        if (count > 1)
            while (count >= 1) {
                const int pos = result.indexOf(label);
                if (pos != -1)
                    result.replace(pos, label + "#" + QString::number(count));
                count = result.count(label);
            }
    }
}

void AADLIfaceRequired::namesForRIsToPI(QStringList &result) const
{
    const AADLFunctionType *parentFn = function();
    if (!parentFn)
        return;

    auto findRI = [](const AADLConnection *in, const AADLIfaceProvided *pi) -> AADLIfaceRequired * {
        if (in && pi)
            for (AADLIface *iface : { in->sourceInterface(), in->targetInterface() })
                if (iface && iface != pi && iface->isRequired())
                    return qobject_cast<AADLIfaceRequired *>(iface);
        return nullptr;
    };

    const shared::Id &parentId = parentFn->id();
    for (const AADLIfaceProvided *pi : m_prototypes) {
        const QVector<AADLConnection *> &relatedConnecions = objectsModel()->getConnectionsForIface(pi->id());
        for (auto i = relatedConnecions.crbegin(); i != relatedConnecions.crend(); ++i) {
            AADLConnection *c = *i;

            const bool sameSrcFn = c->source() && c->source()->id() == parentId;
            const bool sameDstFn = c->target() && c->target()->id() == parentId;
            const bool sameFn = sameSrcFn || sameDstFn;
            const bool isMeSrc = sameFn && c->sourceInterface() == this;
            const bool isMeDst = sameFn && c->targetInterface() == this;
            const bool toSibling = !isMeSrc && !isMeDst;
            if (toSibling)
                if (AADLIfaceRequired *otherRI = findRI(c, pi)) {
                    if (!otherRI->isInheritPI())
                        continue;

                    const QString &oldLabel = pi->title();
                    const int labelPos = result.indexOf(oldLabel);
                    if (labelPos >= 0) {
                        result.replace(labelPos, oldLabel + "#" + QString::number(relatedConnecions.indexOf(c)));
                    }
                }
        }
    }
}

void AADLIfaceRequired::setPrototype(const AADLIfaceProvided *pi)
{
    if (!pi || !isInheritPI())
        return;

    if (!m_prototypes.contains(pi))
        m_prototypes.append(pi);

    if (!m_prototypes.isEmpty())
        cloneInternals(pi);

    Q_EMIT inheritedLabelsChanged(inheritedLables());
}

void AADLIfaceRequired::unsetPrototype(const AADLIfaceProvided *pi)
{
    if (!pi)
        return;

    m_prototypes.removeAll(pi);
    if (m_prototypes.isEmpty() || !isInheritPI())
        restoreInternals(pi);

    Q_EMIT inheritedLabelsChanged(inheritedLables());
}

QString AADLIfaceRequired::ifaceLabel() const
{
    return ifaceLabelList().join(", ");
}

/*! Get the list of labels for this interface. It will either have the
 * inherited names or, if this is empty, the title. There will always
 * be at least one in the returned list.
 */
QStringList AADLIfaceRequired::ifaceLabelList() const
{
    if (isInheritPI()) {
        const QStringList &labels = inheritedLables();
        if (!labels.isEmpty()) {
            return labels;
        }
    }
    return { AADLIface::ifaceLabel() };
}

bool AADLIfaceRequired::isInheritPI() const
{
    return prop(meta::Props::token(meta::Props::Token::InheritPI)).toBool();
}

bool AADLIfaceRequired::hasPrototypePi() const
{
    return m_prototypes.size();
}

void AADLIfaceRequired::cloneInternals(const AADLIface *from)
{
    AADLIface::cloneInternals(from);

    if (const AADLFunctionType *fn = function()) {
        const QVector<AADLIface *> ifaces = fn->allInterfaces();
        const auto it = std::find_if(ifaces.cbegin(), ifaces.cend(),
                [this](const AADLIface *iface) { return iface != this && iface->title() == title(); });
        if (it != ifaces.cend()) {
            setTitle(from->function()->title() + QLatin1Char('_') + from->title());
        }
    }

    if (const AADLIfaceRequired *ri = from->as<const AADLIfaceRequired *>())
        connect(ri, &AADLIfaceRequired::propChanged_InheritPI, this, &AADLIfaceRequired::propChanged_InheritPI,
                Qt::UniqueConnection);
}

void AADLIfaceRequired::restoreInternals(const AADLIface *disconnectMe)
{
    AADLIface::restoreInternals(disconnectMe);
    if (const AADLIfaceRequired *ri = disconnectMe->as<const AADLIfaceRequired *>())
        disconnect(ri, &AADLIfaceRequired::propChanged_InheritPI, this, &AADLIfaceRequired::propChanged_InheritPI);
}

}
